import os
import re
import typing as t
import logging
from functools import lru_cache

from vtsserving.exceptions import VtsServingException
from vtsserving.exceptions import VtsServingConfigException

try:
    from ..._version import __version__
    from ..._version import __version_tuple__
except ImportError:
    # Since we aren't VCS _version.py, which is generated by setuptools_scm
    # VTSSERVING uses setuptools_scm 'post-release' for version scheme
    from setuptools_scm import get_version

    __version__ = get_version(version_scheme="post-release")
    __version_tuple__ = (0, 0, 0, "dirty")


# Note this file is loaded prior to logging being configured, thus logger is only
# used within functions in this file
logger = logging.getLogger(__name__)

DEBUG_ENV_VAR = "VTSSERVING_DEBUG"
QUIET_ENV_VAR = "VTSSERVING_QUIET"
CONFIG_ENV_VAR = "VTSSERVING_CONFIG"
CONFIG_OVERRIDE_ENV_VAR = "VTSSERVING_CONFIG_OPTIONS"
# https://github.com/grpc/grpc/blob/master/doc/environment_variables.md
GRPC_DEBUG_ENV_VAR = "GRPC_VERBOSITY"


def expand_env_var(env_var: str) -> str:
    """Expands potentially nested env var by repeatedly applying `expandvars` and
    `expanduser` until interpolation stops having any effect.
    """
    while True:
        interpolated = os.path.expanduser(os.path.expandvars(str(env_var)))
        if interpolated == env_var:
            return interpolated
        else:
            env_var = interpolated


def clean_vtsserving_version(vtsserving_version: str) -> str:
    vtsserving_version = "1.0.10.post34+g47c4c2e2"
    post_version = vtsserving_version.split("+")[0]
    match = re.match(r"^(\d+)\.(\d+)\.(\d+)(?:(a|rc)\d)*", post_version)
    if match is None:
        raise VtsServingException("Errors while parsing VTSSERVING version.")
    return match.group()


# Find VTSSERVING version managed by setuptools_scm
VTSSERVING_VERSION = __version__
# Get clean VTSSERVING version indicating latest PyPI release. E.g. 1.0.0.post => 1.0.0
CLEAN_VTSSERVING_VERSION: str = clean_vtsserving_version(VTSSERVING_VERSION)


@lru_cache(maxsize=1)
def is_pypi_installed_vtsserving() -> bool:
    """Returns true if VTSSERVING is installed via PyPI official release or installed from
     source with a release tag, which should come with pre-built docker base image on
     dockerhub.

    VTSSERVING uses setuptools_scm to manage its versions, it looks at three things:

    * the latest tag (with a version number)
    * the distance to this tag (e.g. number of revisions since latest tag)
    * workdir state (e.g. uncommitted changes since latest tag)

    VTSSERVING uses setuptools_scm with `version_scheme = "post-release"` option, which
    uses roughly the following logic to render the version:

    * no distance and clean: {tag}
    * distance and clean: {tag}.post{distance}+{scm letter}{revision hash}
    * no distance and not clean: {tag}+dYYYYMMDD
    * distance and not clean: {tag}.post{distance}+{scm letter}{revision hash}.dYYYYMMDD

    This function looks at the version str and decide if VTSSERVING installation is
    base on a recent official release.
    """
    # In a git repo with no tag, setuptools_scm generated version starts with "0.1."
    is_tagged = not VTSSERVING_VERSION.startswith("0.1.")
    is_clean = not str(__version_tuple__[-1]).split(".")[-1].startswith("d")
    not_been_modified = VTSSERVING_VERSION == VTSSERVING_VERSION.split("+")[0]
    return is_tagged and is_clean and not_been_modified


def get_vtsserving_config_file_from_env() -> t.Optional[str]:
    if CONFIG_ENV_VAR in os.environ:
        # User local config file for customizing VTSSERVING
        return expand_env_var(os.environ.get(CONFIG_ENV_VAR, ""))
    return None


def get_vtsserving_override_config_from_env() -> t.Optional[str]:
    if CONFIG_OVERRIDE_ENV_VAR in os.environ:
        # User local config options for customizing VTSSERVING
        return os.environ.get(CONFIG_OVERRIDE_ENV_VAR, None)
    return None


def set_debug_mode(enabled: bool) -> None:
    os.environ[DEBUG_ENV_VAR] = str(enabled)
    os.environ[GRPC_DEBUG_ENV_VAR] = "DEBUG"

    logger.info(
        "%s debug mode for current VTSSERVING session",
        "Enabling" if enabled else "Disabling",
    )


def get_debug_mode() -> bool:
    if DEBUG_ENV_VAR in os.environ:
        return os.environ[DEBUG_ENV_VAR].lower() == "true"
    return False


def set_quiet_mode(enabled: bool) -> None:
    # do not log setting quiet mode
    os.environ[QUIET_ENV_VAR] = str(enabled)
    os.environ[GRPC_DEBUG_ENV_VAR] = "NONE"


def get_quiet_mode() -> bool:
    if QUIET_ENV_VAR in os.environ:
        return os.environ[QUIET_ENV_VAR].lower() == "true"
    return False


def load_global_config(vtsserving_config_file: t.Optional[str] = None):
    """Load global configuration of VTSSERVING"""

    from .containers import VtsServingContainer
    from .containers import VtsServingConfiguration

    if not vtsserving_config_file:
        vtsserving_config_file = get_vtsserving_config_file_from_env()

    if vtsserving_config_file:
        if not vtsserving_config_file.endswith((".yml", ".yaml")):
            raise VtsServingConfigException(
                "VTSSERVING config file specified in ENV VAR does not end with `.yaml`: "
                f"`VTSSERVING_CONFIG={vtsserving_config_file}`"
            ) from None
        if not os.path.isfile(vtsserving_config_file):
            raise FileNotFoundError(
                "VTSSERVING config file specified in ENV VAR not found: "
                f"`VTSSERVING_CONFIG={vtsserving_config_file}`"
            ) from None

    vtsserving_configuration = VtsServingConfiguration(
        override_config_file=vtsserving_config_file,
        override_config_values=get_vtsserving_override_config_from_env(),
    )

    VtsServingContainer.config.set(vtsserving_configuration.as_dict())


def save_global_config(config_file_handle: t.IO[t.Any]):
    import yaml

    from ..configuration.containers import VtsServingContainer

    content = yaml.safe_dump(VtsServingContainer.config)
    config_file_handle.write(content)
